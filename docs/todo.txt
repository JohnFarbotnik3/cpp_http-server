

> write thorough request tests to ensure stability (and correctness!) of server, including when pipelining.
- testing a bunch of GET, PUT, DELETE operations against static_file_server would be an easy way to do this.


> create combined server for ff-extensions
- will require multiple features/handlers (likely as separate servers):
	- sqlite DB (ex: for storing maps of form: Map<db_name, Map<post_id, post_json>>)
		^ target = "localhost:xxxx/dbname"
		^ method = "GET|PUT|DELETE"
		^ HTTPS + password authenticated (using cookie?).
	- caching proxy
		^ target = "localhost:yyyy/URI"
		^ custom header = "x-cachemode: file_cache|temp_cache|no_cache"
		^ config: file_cache_dir, temp_cache_dir.
	- ML service (ex: for processing thumbnail + post_json)
		^ target = "localhost:zzzz/compute_score"
		^ method = "POST"
		^ map from {thumbnail + one-hot-tags-encoding} to {estimated_post_score}
		^ score encoder model can be trained externally with a separate interface.
		^ training data: thumbnails with json metadata sorted into folders "0, 10, 20, ..., 90, 100"
...


> implement abuse prevention metrics and mechanisms:
	- max 24 connections per IPv4.
	- max 12 connections per IPv6.
	? max XX connections per IPv4/6 subnet.
	- max request time: 2s + 1s/200KiB.
	- max request head size: <MAX>.
	- max request body size: <MAX>.
	- max requests per 5sec: <MAX>.
	- max bandwidth per 10sec: <MAX>.
	- min request packet size: <MIN>.
	- max memory per IPv4/subnet.
	- max memory per IPv6/subnet.
	- prevent directory-escape.
	- prevent probing for configs, certs, etc.
	* respond with rate limiting status.
	* block IP/IP-subnet for 5-30 minutes on violation.
	* notify admin on high resource usage: memory usage, connections/file-descriptors, cpu load over time, etc.
	* have different log levels for different levels of abuse.
	* have system resource usage logs (1hz), in comma-delimited table format.
	* implement log rotation.
...



> correctness test:
- use static_file_server handler.
- use GET, PUT, DELETE operations.
- treat server as if it is a Map.
- use a Map client-side to store values.
- generate a bunch of random requests to see if correct values are returned,
as well as to determine performance under continuous load.


> implement CORS related stuff:
https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Security-Policy#directives
https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Permissions-Policy#directives

> figure out how hard it is to make server capable of basic HTTPS (self-signed),
for purposes of more secure local use. (SSL/TLS)
- steps:
	- download openSSL source.
	- build source into library. (learn how to do this)
	- link project against library. (learn how to do this)
	? statically linked or dynamically linked?
	? is libCURL needed here?
...

> add support for ranges in GET/HEAD requests.
https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Range_requests



> implement connection close after N seconds of no traffic.
* HTTPServer should have a list of connections and connection stats.
	worker-thread buffers and sockets should be part of connection_data struct.
* HTTPServer should have a "housekeeping/watchdog" thread which scans through
the list of connections, searching through connections with a "last-activity"
timestamp that is greater than "keep-alive" duration.
* sockfd can be used as index in list.


> fix SEVERE bug where server just exits without even printing an error message.
- discovered in HTTP mode, but probably applies to HTTPS as well.








