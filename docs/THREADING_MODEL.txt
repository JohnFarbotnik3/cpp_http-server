

> functions of interest:
	- "poll" - get list of FDs that are ready to read/write.
	- "epoll" - poll, but better.
	- "select" - supposedly outdated; learn about, but use poll/epoll instead.
...

> open questions:
	? performance of select vs poll vs epoll?
	? cost of having/manipulating large number of mutexes? (ex. mutex per connection)
	? what happens if multiple threads poll, data arrives,
		and multiple thread wake up and try to recv data simulataneously?
	? semaphore with number of tasks available for threads,
		so that wake up right when they are needed,
		and only the needed number of threads wakes up?
	? what is the "thundering herd" problem (multithreading)?
...

> shared structures:
	* connection queues:
		- each queue will have an ordered-set of connection-keys corresponding to connections to handle.
		- a connection shall be in exactly 1 or 0 queue(s) at a time, based on its current state.
		- a worker thread pops the first connection from the queue when starting to work on it.
		- a counting-semaphore will track number of items in work_queue, so that worker threads are awoken as needed.
	- connections: list of connections, indexed by FD.
	- recv_array: blocked connections waiting to recv data.			<managed by a polling thread>
	- work_queue: connections with data to send, recv, or process.	<managed by a worker thread-pool>
	- send_array: blocked connections waiting to send data.			<managed by a polling thread>
...

> connection lifecycle:
	* connections will have a state, and a cursor for each MessageBuffer.
	- connection starts of in "recv_array" with state "WAITING_FOR_HEAD".
	- polling thread moves it to "work_queue" when it has data to read.
	- once in "work_queue", worker thread pop it from queue and handle it based on connection state:
		WAITING_FOR_HEAD: recv until completed head, or socket blocks.
		WAITING_FOR_BODY: recv until completed body, or socket blocks.
		BEING_PROCESSED: (intermediate state.)
		WAITING_TO_SEND_HEAD: send until head is sent, or socket blocks.
		WAITING_TO_SEND_BODY: send until body is sent, or socket blocks.
		CLOSED: a polling/worker thread discovered that socket is closed.
	* if a socket blocks, move connection to "send_array" or "recv_array".
	x problems:
		- what if connection is closed by housekeeping thread during polling?
		- what if connection is closed while being operated on be a worker thread?
	^ solution: after reading the documentation for poll(), I suspect the following:
		- (~90-99%) if a connection is closed during polling, then poll() will return events
			with flags other than POLLIN/POLLOUT.
		- (~1-10%) if connection closes while being processed by worker, then worker can detect this when trying to send/recv.
		? (<0.01%) if connection closes just after worker is done with it and is currently moving it to a polling set,
			then there will be a closed connection in the poll list. I think it will immediately return POLLNVAL (?).
		* in all cases, a worker should eventually detect the closed connection and can safely delete it
			(since it is only in at most 1 queue/set at a time).
...

> threads:
	- master thread.
	- housekeeping thread.
		- periodically scan connections/ip-addresses.
		- close connections after timeout (time with no activity > keepalive duration).
		- close connections for DOS/abuse.
	- acceptor thread-pool:
		- use mutex/semaphore so that only one is waiting for accept() at a time.
		^ would this cause "thundering herd"? it may actually be better to not use a mutex.
	- worker thread-pool:
		- worker threads will process connections in work_queue based on their current state.
	- polling threads:
		- poll list of blocked sockets to check when they become unblocked.
...

> modules:
	* these should be mostly self contained, each with their own "master threads".
		these will have shared task-queues that the rest of the server can
		add/remove tasks to/from.
	* create a common ServerModule struct which modules can subclass.
	- static_file_server:
		- one shared request/response queue.
		- multiple worker threads.
		- only one thread should operate on a particular file at a given moment.
		- should have module config specifying target directory, and access rules.
	- sqlite_database:
		- one shared request/response queue.
		- multiple worker threads.
		- only one thread should operate on a particular database-file at once.
		- should have module config specifying database-files directory, and access rules.
...

> note: blocked worker-threads.
	right now the server is not designed to handle blocking during the handling phase
	of the request-lifecycle; for example if the request handler needs to make
	a request to another server.

	in theory, additional task-queues and polling-threads could be added to address this,
	however this greatly increases complexity. a simpler solution would be to:
	- have more worker threads than processor cores (example 2*N_CORES).
	- maintian a low-latency connection with the other services.
	- and have timeouts in case some services temporarily become unavailable.

	it does not actually solve the problem, but it is a simple mitigation to implement.
...



